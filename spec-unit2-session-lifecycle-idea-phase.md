# Spec Unit 2 — Session Lifecycle & Idea Phase Model

**Idea:** Session Tab
**App:** Command Center
**Session:** S-2026-02-14-008
**Depends on:** Spec Unit 1 (session.json schema & package format)
**Phase:** spec-ready

---

## 1. Overview

This spec defines two independent state models that operate on the Command Center landing page:

- **Session state** — the lifecycle of a single work cycle (pending → active → complete)
- **Idea phase** — the cumulative maturity of an idea (inception → exploring → converging → spec-ready → complete)

These are independent dimensions displayed on the same session card. Session state tracks the current work cycle. Idea phase tracks cumulative progress across all sessions. Both are visible simultaneously.

---

## 2. Session Lifecycle

### 2.1 State Machine

A session has three states:

| State | Entry Trigger | Description |
|-------|--------------|-------------|
| **pending** | Session completes, or idea is created with no session history | No session in flight. The idea is on the landing page awaiting the next work cycle. "Generate Brief" is the primary action. |
| **active** | Brief generated | Session object created in Firebase. Chain progress tracked. Link artifacts may or may not have arrived yet. The card transforms into the live chain tracker. |
| **complete** | Summation package ingested | Session record freezes. Full record (chain progress, link artifacts, ODRC counts, timestamps, debrief) persists as the historical entry. Card resets to pending for the next cycle. |

**State transitions:**

```
pending → active       (brief generation)
active → complete      (summation ingestion)
complete → pending     (automatic — idea card resets for next session)
```

There is no backward transition. A session cannot move from active back to pending. If a session is abandoned, it remains active until explicitly closed (see §2.3 Staleness).

### 2.2 Session Object Lifecycle

The session object is created at brief generation and persists through completion into the historical record. The same object serves both the live landing page view and the historical session tab view — they are the same data at different lifecycle stages.

**Created at brief generation (pending → active):**

| Field | Source | Description |
|-------|--------|-------------|
| `session_id` | Generated by CC | Format: `S-YYYY-MM-DD-NNN` |
| `idea_id` | From idea record | Firebase key of the parent idea |
| `idea_slug` | From idea record | URL-safe idea identifier |
| `idea_name` | From idea record | Human-readable idea name |
| `app` | From idea record | App the idea belongs to |
| `status` | Set to `active` | Session state |
| `created_at` | Timestamp | When brief was generated |
| `idea_phase_at_start` | From idea record | Snapshot of idea phase when session began |
| `brief_downloaded` | Boolean | Whether the brief zip was downloaded |
| `chain` | Initialize empty | `{ link_count: 0, links: [], artifacts_received: 0 }` |

**Updated during active session:**

| Field | Source | Description |
|-------|--------|-------------|
| `chain.link_count` | Incremented on artifact arrival | Number of link artifacts received |
| `chain.links[]` | Appended on artifact arrival | Array of link metadata (filename, received_at, type) |
| `chain.artifacts_received` | Count | Total artifacts collected |
| `last_activity_at` | Timestamp | Updated on each artifact upload |

**Set at completion (active → complete):**

| Field | Source | Description |
|-------|--------|-------------|
| `status` | Set to `complete` | Session state |
| `completed_at` | Timestamp | When summation was ingested |
| `debrief_summary` | From session.json | First 2-3 paragraphs of the debrief narrative |
| `odrc_counts` | From session.json | `{ opens: N, decisions: N, rules: N, constraints: N, resolved: N }` |
| `session_config` | From session.json | `{ mode, lens }` |
| `context_summary` | From session.json | One-line summary of what the session accomplished |
| `next_session` | From session.json | Recommendation for the next session |
| `value_rating` | Developer input | 1-10 rating provided at ingestion time |
| `idea_phase_at_end` | From idea record | Snapshot of idea phase when session completed |

### 2.3 Staleness Detection

Staleness is a derived condition, not a state. CC evaluates staleness on active sessions using signals:

**Staleness signals:**
- `brief_downloaded == true` AND `chain.artifacts_received == 0` AND age > threshold (e.g., 7 days)
- `last_activity_at` older than threshold with session still active (e.g., 14 days since last artifact)

**Staleness response:**
- CC surfaces a nudge on the session card: "You dispatched this session N days ago. Resume or abandon?"
- **Abandon** sets `status` to `complete` with a flag `abandoned: true` and no summation data. The card resets to pending.
- **Resume** dismisses the nudge. CC may re-nudge after another threshold period.

Staleness thresholds are configurable. Start with 7 days (no artifacts) and 14 days (stale activity). Refine based on usage patterns.

### 2.4 Session-to-Idea Relationship

Sessions maintain a strict one-to-one relationship with ideas:

- Each session belongs to exactly one idea
- An idea can have many sessions (sequential, not concurrent — only one active session per idea at a time)
- The session output (session.json) carries the idea slug and idea ID, linking back to the parent idea
- All edge cases (merging ideas, cross-idea ODRC, parent/child hierarchies) are CC backend management concerns, not session protocol concerns

**One active session per idea constraint:** When a session is active for an idea, the "Generate Brief" action is unavailable for that idea. The developer must complete or abandon the current session before starting a new one. This prevents orphaned sessions and conflicting ODRC updates.

---

## 3. Idea Phase Model

### 3.1 Phase Values

| Phase | Description | Chat Behavior |
|-------|-------------|---------------|
| **inception** | Idea is provisional. Has a name and topic sentence but hasn't been validated. | Brief includes validation directive: challenge the name, pressure-test the topic sentence, confirm the end goal. 3-4 questions, first five minutes. |
| **exploring** | Idea is validated. Actively surfacing OPENs and making early Decisions. | Normal session flow. Phase is context on the brief but doesn't alter Chat behavior. |
| **converging** | Decisions outnumber OPENs. Rules emerging. Idea shape is solidifying. | Normal session flow. Phase is context on the brief. |
| **spec-ready** | OPENs near zero. Strong Rules and Constraints. Ready for specification. | Normal session flow. Phase is context on the brief. |
| **complete** | Idea is done — spec built, shipped, or explicitly archived. Terminal state. | Idea leaves the landing page. Historical record preserved in session tab. |

**Key behavioral distinction:** Only inception changes Chat's behavior. All other phases are informational context that CC displays and Chat acknowledges but does not act on differently. This keeps the session protocol simple — Chat has one behavioral branch (inception vs. everything else), not five.

### 3.2 Phase Transitions

Phase transitions are developer-driven. CC provides advisory signals but never gates progress.

```
inception → exploring       (developer advances after validation)
exploring → converging      (developer advances; CC shows ratio signal)
converging → spec-ready     (developer advances; CC shows ratio signal)
spec-ready → complete       (developer advances after spec/build)
```

**No backward transitions.** If an idea needs to revisit earlier exploration, the developer creates new sessions in the current phase — the phase doesn't regress. The ODRC state and session history already capture the evolution.

**Skip transitions are allowed.** A developer can advance from inception directly to converging if they've done extensive thinking outside CC. The phase reflects the developer's assessment, not a gate.

### 3.3 Phase Signals (Advisory)

CC calculates ratio-based signals from the cumulative ODRC state to suggest when a phase transition may be appropriate. These are displayed on the session card as subtle indicators, not prompts.

| Signal | Heuristic | Suggestion |
|--------|-----------|------------|
| OPENs >> Decisions | Ratio > 2:1 | Still exploring |
| Decisions > OPENs, Rules emerging | Ratio inverted, 2+ Rules | Converging |
| OPENs near zero, strong Rules/Constraints | < 3 unresolved OPENs | Spec-ready |

**Implementation note:** Don't over-invest in phase calculation sophistication. The ratio heuristic is a quick gut-check, not precision. Start with these simple ratios and refine only if usage reveals the signals are misleading.

### 3.4 Inception Validation

When an idea is in inception phase, the session brief includes a validation directive block:

```
## Inception Validation
This is a new idea that hasn't been validated yet. Before exploring:
1. Challenge the idea name — does it accurately describe the concept?
2. Pressure-test the topic sentence — is it specific enough to scope work?
3. Confirm the end goal — what does "done" look like for this idea?

Spend the first 3-5 minutes on validation. If answers are confident, move on.
If vague, suggest stepping back to refine the idea definition before deep exploration.
```

This directive is embedded by the brief generator when `idea.phase === 'inception'`. It is not included for any other phase.

After validation, the session can recommend advancing the phase to exploring. The developer confirms in CC.

### 3.5 Default Phase

Every new idea defaults to **inception**. The developer can override at creation time (e.g., if the idea has been extensively thought through offline and starts at exploring or converging).

---

## 4. Interaction Model — Session State × Idea Phase

Session state and idea phase are independent dimensions on the session card. Here's how they interact:

### 4.1 Card Presentation Matrix

| Session State | Card Behavior |
|--------------|---------------|
| **pending** | Shows idea name, cumulative ODRC counts, idea phase badge, "Generate Brief" action. If previous sessions exist, shows last session's debrief summary. |
| **active** | Live chain tracker: link progress indicators, ODRC velocity (resolved/new), elapsed time, "Download Link Package" action. Idea phase badge still visible. |
| **complete** | Momentary — session summary displayed, then card resets to pending with updated cumulative ODRC state. Complete sessions live in session history tab. |

### 4.2 Phase Badge

The idea phase is displayed as a badge or label on the session card:

- **inception** — signals this is a new, unvalidated idea
- **exploring** / **converging** / **spec-ready** — informational, shows maturity
- **complete** — idea is terminal, card should not appear on landing page

The phase badge updates when the developer advances the phase in CC, independent of session state.

### 4.3 Lifecycle Example

```
1. Developer creates idea "Session Tab" → phase: inception, no session
   Card: pending | inception | "Generate Brief"

2. Developer clicks "Generate Brief" → session S-001 created
   Card: active | inception | chain tracker

3. Session S-001 completes, Chat recommended advancing to exploring
   Card: pending | inception → developer advances → exploring
   Card: pending | exploring | "Generate Brief"

4. Developer generates brief for session S-002
   Card: active | exploring | chain tracker

5. After several sessions, ODRC ratio shifts. Developer advances phase.
   Card: pending | converging | "Generate Brief"

6. Eventually spec is built, idea marked complete.
   Card removed from landing page. Full history in session tab.
```

---

## 5. Firebase Data Model

### 5.1 Existing Infrastructure

The codebase has two relevant existing systems:

**SessionService** (line ~1375) — The legacy session tracker for the Claude Prep → Build → Deploy pipeline. Uses `command-center/{uid}/sessions` with `sess-{timestamp}` IDs and states `prep | active | completed | abandoned`. This service tracks build sessions (AI code generation cycles), not ideation sessions.

**Idea records** (IdeaManager, line ~5785+) — Ideas live under `command-center/{uid}/ideas`. They already carry a `phase` field (nullable), a `sessionLog` array with session history, a `slug`, and a `status` field (`active` for live ideas). The `computeIdeaPhase()` function (line ~5968) calculates phase from ODRC ratios when no manual phase is set.

**Key distinction:** The existing `SessionService` tracks *build* sessions (code generation). The ideation session lifecycle defined in this spec tracks *ideation* sessions (ODRC exploration chains). These are different objects in different contexts, though they may converge in a future refactoring.

### 5.2 Ideation Session Record

Ideation sessions are tracked on the idea record via the existing `sessionLog` array, enriched with lifecycle fields. The `SessionPackageProcessor.buildSessionLogEntry()` (line ~2890) already maps session.json data into this format.

**Current sessionLog entry format** (from `executeODRCImport`, line ~3090):

```json
{
  "sessionId": "S-2026-02-14-008",
  "date": 1739520000000,
  "summary": "12 concept(s) created, 0 OPEN(s) resolved",
  "conceptsCreated": 12,
  "conceptsResolved": 0,
  "type": "exploration"
}
```

**Enriched sessionLog entry format** (from `SessionPackageProcessor.buildSessionLogEntry()`, line ~2890):

```json
{
  "sessionId": "S-2026-02-14-008",
  "date": "2026-02-14",
  "summary": "Produced spec Unit 1...",
  "conceptsCreated": 10,
  "conceptsResolved": 0,
  "type": "exploration",
  "chain": {
    "linkCount": 3,
    "summation": true,
    "totalConceptBlocks": 18,
    "totalElapsedMinutes": 90
  },
  "debriefSummary": "This session produced...",
  "nextSession": "Begin spec Unit 2...",
  "schemaVersion": "1.0.0"
}
```

**New fields for ideation session lifecycle** (added to the sessionLog entry):

| Field | Type | Description |
|-------|------|-------------|
| `status` | string | `active` \| `complete` \| `abandoned` |
| `createdAt` | ISO string | When brief was generated (session activated) |
| `completedAt` | ISO string \| null | When summation was ingested |
| `lastActivityAt` | ISO string \| null | Last artifact upload timestamp |
| `briefDownloaded` | boolean | Whether the brief zip was actually downloaded |
| `ideaPhaseAtStart` | string | Snapshot of idea phase at session creation |
| `ideaPhaseAtEnd` | string \| null | Snapshot of idea phase at session completion |
| `valueRating` | number \| null | Developer's 1-10 rating at ingestion |
| `sessionConfig` | object \| null | `{ mode, lens }` from session.json |
| `contextSummary` | string \| null | One-line summary from session.json |
| `odrCounts` | object \| null | `{ opens, decisions, rules, constraints, resolved }` |
| `artifactsReceived` | number | Count of link artifacts received during active |

**Design rationale:** Ideation sessions live on the idea's `sessionLog` rather than in the separate `SessionService` path. This keeps the idea as the unit of navigation — when you look at an idea, its full session history is right there. The existing `SessionService` remains for build sessions until a future unification effort.

### 5.3 Active Session Tracking

To support the landing page's live session card, the idea record gains a top-level field:

```json
{
  "activeSession": {
    "sessionId": "S-2026-02-14-008",
    "status": "active",
    "createdAt": "2026-02-14T10:00:00Z",
    "lastActivityAt": "2026-02-14T10:00:00Z",
    "briefDownloaded": true,
    "artifactsReceived": 0,
    "ideaPhaseAtStart": "converging"
  }
}
```

When a session completes, `activeSession` is set to `null` and the full enriched entry is appended to `sessionLog`. This gives CC a single field to check for landing page rendering without scanning the sessionLog array.

### 5.4 Idea Record — Phase Field

The `phase` field already exists on idea records (nullable, line ~5933). Currently:
- If `null`, `computeIdeaPhase()` calculates from ODRC ratios (returns `exploring`, `converging`, or `spec-ready`)
- If set, it's used as a manual override

**Changes needed:**
- Add `inception` and `complete` as recognized values
- Update `computeIdeaPhase()` to never return `inception` or `complete` (these are always developer-set)
- Add `inception` and `complete` to `PHASE_COLORS` (line ~15753)
- Update `IdeationBriefGenerator.getSessionType()` (line ~3167) to handle `inception` phase
- Add `phase_updated_at` timestamp field
- Default new ideas to `inception` phase (currently defaults to `null` which computes as `exploring`)

**Updated PHASE_COLORS:**
```javascript
const PHASE_COLORS = {
    inception:    { stripe: '#94a3b8', bg: 'rgba(148,163,184,0.15)', text: '#94a3b8' },
    exploring:    { stripe: '#3b82f6', bg: 'rgba(59,130,246,0.15)',  text: '#3b82f6' },
    converging:   { stripe: '#f59e0b', bg: 'rgba(245,158,11,0.15)', text: '#f59e0b' },
    'spec-ready': { stripe: '#f093fb', bg: 'rgba(240,147,251,0.15)', text: '#f093fb' },
    complete:     { stripe: '#22c55e', bg: 'rgba(34,197,94,0.15)',   text: '#22c55e' }
};
```

Note: `building` currently exists in PHASE_COLORS but is not in the spec's phase model. It should be removed or aliased to a spec-defined phase.

### 5.5 Querying Patterns

| Query | Implementation |
|-------|---------------|
| Active sessions for landing page | Ideas where `activeSession != null` |
| Session history for an idea | Read `idea.sessionLog` array |
| Stale session detection | Ideas where `activeSession != null` AND `activeSession.artifactsReceived == 0` AND age > threshold |
| Ideas at inception | Ideas where `phase == 'inception'` |
| Completed ideas (archive) | Ideas where `phase == 'complete'` |
| One-active-session check | Before generating brief: verify `idea.activeSession == null` |

---

## 6. Brief Generation Integration

### 6.1 Session Creation Flow

When the developer clicks "Continue" (currently "Generate Brief" on IdeaWorkCard, line ~15796):

1. CC checks `idea.activeSession` — if non-null, block and surface the active session
2. CC creates the `activeSession` object on the idea record with `status: active`
3. CC snapshots `idea.phase` (or `computeIdeaPhase()` result) into `ideaPhaseAtStart`
4. CC generates the session brief via `IdeationBriefGenerator.generate()` (line ~3305)
5. If `idea.phase === 'inception'`, the brief includes the inception validation directive (§3.4)
6. The session ID and idea metadata are embedded in the brief
7. CC packages the brief as a zip for download
8. `activeSession.briefDownloaded` is set to `true` when the download occurs

### 6.2 IdeationBriefGenerator Changes

**`getSessionType()` (line ~3167)** needs an inception branch:

```javascript
getSessionType(idea, concepts) {
    const phase = idea.phase || computeIdeaPhase(concepts);
    if (phase === 'inception') return 'exploration'; // inception uses exploration flow with validation directive
    const hasSpec = (idea.sessionLog || []).some(s => s.type === 'spec');
    if (phase === 'spec-ready' && hasSpec) return 'claude-md';
    if (phase === 'spec-ready') return 'spec';
    return 'exploration';
}
```

**`getSystemPrompt()` for exploration** (line ~3286) needs an inception conditional — when `phase === 'inception'`, append the validation directive block to the system prompt so the AI brief generator embeds it.

**`buildUserMessage()` (line ~3364)** already passes phase. No changes needed — the system prompt handles inception awareness.

### 6.3 One Active Session Constraint

CC enforces that only one session can be active per idea at a time. The check is simple: `if (idea.activeSession) { show warning; return; }`.

If the developer attempts to generate a brief while a session is active, CC surfaces: "Session {sessionId} is still active. Complete or abandon it before starting a new session."

---

## 7. Session Completion Flow

When CC receives a summation package (session.json + debrief.md in a zip):

1. `detectInboundArtifactType()` (line ~3004) identifies the session.json as `'session-json'` (highest priority path)
2. `SessionPackageProcessor.validate()` (line ~2812) validates against schema
3. `SessionPackageProcessor.extractMetadata()` (line ~2911) extracts `ideaSlug`, `ideaId`, `sessionNumber`, `appId`
4. CC matches `ideaId` to the idea record and verifies `idea.activeSession.sessionId` matches
5. `SessionPackageProcessor.buildSessionLogEntry()` (line ~2890) builds the enriched session log entry
6. CC merges lifecycle fields into the log entry: `status: 'complete'`, `completedAt`, `valueRating`, `ideaPhaseAtEnd`
7. `executeODRCImport()` (line ~3046) processes ODRC items via the import checklist UI
8. `IdeaManager.addSessionLogEntry()` (line ~3101) appends the entry to `idea.sessionLog`
9. CC sets `idea.activeSession` to `null`
10. Developer provides `valueRating` (1-10) at ingestion time
11. Landing page card resets to pending, showing updated cumulative ODRC counts

**Mismatched session ID:** If the package's session ID doesn't match `idea.activeSession.sessionId`, CC surfaces a warning but still allows ingestion. The developer may have generated the brief outside CC or the session record may have been lost. Don't block ingestion over a bookkeeping mismatch.

**No active session:** If the idea has no `activeSession` when a package arrives, CC creates the session log entry directly from session.json data (the `executeODRCImport` fallback path at line ~3086 already handles this). The session is recorded as complete without having gone through the active lifecycle.

---

## 8. Decision Validation Checkpoint

This section maps the Decisions this spec addresses and flags any concerns.

### Decisions Addressed

| Decision | How Addressed | Concerns |
|----------|--------------|----------|
| Session states: dispatched → active → complete | Simplified to 3 states: pending → active → complete. Pending is the absence of an active session (`activeSession == null`). Staleness is derived, not a state. | "Dispatched" from earlier sessions renamed conceptually — brief generation sets status to `active`. No separate dispatched state. |
| Session is a single object through lifecycle; live view and history are same data | §5.2-5.3: Active session lives on `idea.activeSession`; on completion it's merged into `idea.sessionLog[]` as the enriched entry. Same data, different location during lifecycle. | Slight structural difference from "same object" — it moves from `activeSession` to `sessionLog`. This is a Firebase optimization (fast lookup vs. array scan) but the data is the same. |
| Landing page shows session cards with dual state | §4.1 card presentation matrix defines behavior at each session state. Phase badge is independent. | UX details deferred to Unit 4. |
| Idea phase: inception → exploring → converging → spec-ready → complete | §3.1 defines all five phases. `computeIdeaPhase()` (line ~5968) currently returns only `exploring`, `converging`, `spec-ready` — it needs no change since `inception` and `complete` are always developer-set. | `PHASE_COLORS` (line ~15753) needs `inception` and `complete` added. Existing `building` entry has no corresponding spec phase — should be removed. |
| Developer controls phase transitions; CC provides advisory signals | §3.2 transitions are developer-driven. §3.3 defines ratio-based advisory signals using existing `computeIdeaPhase()` logic. | Phase advancement UI control deferred to Unit 4. |
| Default new ideas to inception; developer can override | §3.5 and §5.4. Currently ideas default to `phase: null` (computes as `exploring`). Implementation must change IdeaManager to default to `inception`. | Migration: existing ideas with `phase: null` should remain computed (not retroactively set to `inception`). Only new ideas get the default. |
| Inception validation: 3-4 questions, first five minutes, not interrogation | §3.4 defines the directive block. §6.2 shows where `IdeationBriefGenerator` needs the inception branch. | The directive wording is a starting point. Refine based on actual session quality. |
| One-to-one session-to-idea relationship | §2.4 defines the constraint. §6.3 enforces one active session per idea via `activeSession` check. | None. |
| Brief generation creates the contract | §6.1 defines the full flow. Session ID is generated at brief time via existing `generateSessionId()` (line ~5984). | None. |
| Stale session detection and safeguard | §2.3 defines staleness as derived signals. Abandon sets `activeSession` to null with an abandoned entry in `sessionLog`. | Thresholds (7/14 days) are starting values. |
| When session completes, card resets to pending | §7 step 9 sets `activeSession` to null, which returns the card to pending presentation. | None. |
| Session record carries debrief_summary for future brief generation | §5.2 `debriefSummary` is already part of the enriched sessionLog entry produced by `SessionPackageProcessor.buildSessionLogEntry()`. | `IdeationBriefGenerator` doesn't currently use `debriefSummary` in brief generation — it uses the basic `summary` field (line ~3391). Enhancement needed to pull `debriefSummary` from the most recent session for richer context. |
| SessionPackageProcessor validates and routes session.json | §7 references the existing processor (line ~2811). No changes to the processor itself — it already handles validation, metadata extraction, and session log entry building. | None. |

### Potential Gaps

1. **`building` phase in PHASE_COLORS:** The codebase has a `building` entry (line ~15755) that doesn't map to any phase in this spec. It should be removed or mapped. If it was intended for a "spec is being implemented by Claude Code" state, that's between `spec-ready` and `complete` — but the spec currently jumps from `spec-ready` to `complete`. **Recommend:** Remove `building` for now. If a build-tracking phase is needed, add it when the Code → CC feedback loop is designed.

2. **`debriefSummary` in brief generation:** The `IdeationBriefGenerator.buildUserMessage()` currently passes `latestSession.summary` (the short summary). It doesn't use `debriefSummary` (the narrative first paragraphs of the debrief). This is a missed opportunity — the debrief summary would give Chat much richer context for the next session. **Recommend:** Update `buildUserMessage()` to include `latestSession.debriefSummary` when available, perhaps as a "Prior Session Context" section.

3. **Phase advancement UX:** This spec defines when and why phase transitions happen but doesn't specify the UI control. Deferred to Unit 4.

4. **Value rating timing:** Developer provides 1-10 rating "at ingestion time." Exact UX deferred to Unit 4.

5. **Concurrent ideas:** Multiple ideas can have active sessions simultaneously (different ideas). This is intended — the developer may work on multiple ideas in parallel. No constraint needed.

6. **Migration of existing ideas:** Existing ideas have `phase: null`. The backfill logic (line ~5933) currently sets `phase: null` for ideas without it. After this implementation, new ideas should default to `inception`, but existing ideas should continue using computed phase (no retroactive inception). The backfill should NOT be changed to set `inception` — that would incorrectly mark mature ideas as provisional.

---

## 9. Dependencies & Cross-References

| Dependency | Relationship |
|------------|-------------|
| **Unit 1: session.json schema** | `SessionPackageProcessor` (line ~2811) already implements the schema contract. This spec references its output fields for session log enrichment. No changes to the processor needed. |
| **Unit 3: Skill updates** | Inception validation directive is embedded in the brief. Session skills (cc-session-structure) may need awareness of inception phase for the opening protocol. |
| **Unit 4: Landing Page UX** | Card presentation, phase badge design, staleness nudge UI, phase advancement controls, value rating UX, the `IdeaWorkCard` component (line ~15760) transformation from current idea-card to session-card. |
| **Unit 5: Ingestion Pipeline** | Session completion flow (§7) overlaps with ingestion. `executeODRCImport()` (line ~3046) and the import checklist modal (line ~12411) already handle ODRC processing. This spec adds lifecycle state management around that existing flow. |
| **Existing SessionService** (line ~1375) | Legacy build session tracker. No changes in this spec. Coexists with the ideation session lifecycle. Future unification is out of scope. |
| **IdeaManager** (line ~5785+) | Gains `activeSession` field on idea records. Existing `addSessionLogEntry()` method used for completion writes. Backfill logic (line ~5933) must NOT retroactively set `inception` on existing ideas. |
| **computeIdeaPhase()** (line ~5968) | No changes needed — already returns `exploring`, `converging`, `spec-ready`. Inception and complete are always developer-set overrides. |
| **IdeationBriefGenerator** (line ~3165) | Needs inception branch in `getSessionType()` and inception directive in the exploration system prompt. |
