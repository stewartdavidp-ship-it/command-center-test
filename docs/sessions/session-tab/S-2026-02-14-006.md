# ODRC Updates — Session Tab
# Date: 2026-02-14
# Session: S-2026-02-14-006 (Spec-readiness assessment — OPEN triage, phase advancement, spec planning)
# Idea: session-tab
# IdeaId: -OlO6yEDlG9FFkjXgAxl
# App: command-center
# Context: Triaged all 13 open OPENs against existing Decisions, resolved 11, advanced idea to spec-ready, and defined a 5-unit spec plan with Decision validation checkpoints.

## ODRC Updates

- RESOLVE OPEN: "Should filenames inside the zip be fully qualified (idea slug + session ID) or generic?" → Already decided: zip filename is fully qualified ({idea-slug}-{session-id}-{date}.zip), internal filenames are generic (session.json, debrief.md). No action needed.
- RESOLVE OPEN: "Does the cc-artifact-manifest skill get absorbed into cc-post-session-package or retain a distinct role?" → cc-artifact-manifest retains its in-session tracking role for work-in-progress and compaction recovery. The session.json artifacts array replaces it for output packaging. cc-post-session-package retires after cc-summation-link validation.
- RESOLVE OPEN: "How does CC trigger brief generation from ingested session data?" → Already decided: developer initiates from the session card, CC generates brief using cumulative ODRC state + last session debrief, session moves to dispatched state. The brief creates the contract, the output fulfills it.
- RESOLVE OPEN: "What error handling is needed when a package is malformed or missing required fields?" → Out of scope for session tab. Error handling is a processor concern. The session tab spec defines the session.json schema as the valid package contract; the processor validates and handles errors against that contract.
- RESOLVE OPEN: "When CC builds a future session brief, does it pull from just the latest cumulative ODRC state or also individual session debriefs?" → Already decided: both. Cumulative ODRC for structured state, debrief (first-class field on session record) for narrative context and reasoning trajectory.
- RESOLVE OPEN: "Does the current ODRC parser do reconciliation or simple append?" → Out of scope for session tab. Reconciliation logic is a processor concern. The session tab spec documents the session.json schema; the processor implements reconciliation against it.
- RESOLVE OPEN: "What does the session package content signature look like for directory watching?" → Reuses existing completion file polling mechanism. CC knows the expected filename pattern from dispatched sessions ({idea-slug}-{session-id}-{date}.zip). Filename matching is sufficient; content inspection is unnecessary.
- RESOLVE OPEN: "For Chrome directory watching, does CC poll on a timer or only on tab focus/mount?" → Reuses existing completion file polling mechanism. Chrome-only via File System Access API. Polling strategy and tuning are implementation details within the established architectural Decision.
- RESOLVE OPEN: "Does the summation link always have the original brief metadata (session ID, slug) available?" → Already decided: session metadata flows through restart docs across the chain. The cc-summation-link skill is the single point where the brief's session metadata flows into the output filename.
- RESOLVE OPEN: "Is the chain model always the right structure, or are there session types where a single deep link produces better results?" → The chain model is advisory infrastructure, not a mandatory structure. A session that completes its purpose within a single link produces output directly without requiring summation. Links are pitstops — available when context needs refueling, not enforced as checkpoints. Summation is only needed when multiple links require cross-link synthesis.
- RESOLVE OPEN: "What does the inception brief template look like?" → Resolved by the idea phase field Decision. The inception brief is the standard brief template with an added validation directive block telling Chat to challenge the name, pressure-test the topic sentence, and confirm the end goal. Not a separate template design — a conditional section in brief generation.
- NEW DECISION: "The chain model is advisory infrastructure, not a mandatory structure. A session that completes its purpose within a single link produces output directly without requiring summation. Links are pitstops — available when context needs refueling, not enforced as checkpoints. Summation is only needed when multiple links require cross-link synthesis."
- NEW DECISION: "Session package detection reuses the existing completion file polling mechanism. Chrome-only via File System Access API. Combined with session card state logic that detects when a developer starts a new session without having uploaded results from the previous dispatched session. Polling tuning and orphan cleanup are implementation details."
- NEW DECISION: "Error handling for malformed packages and ODRC parser reconciliation logic are processor concerns, out of scope for the session tab idea. The session tab spec defines the session.json schema as the valid package contract; the processor spec owns validation, error handling, and reconciliation."
- NEW DECISION: "Idea records carry a phase field with values: inception, exploring, converging, spec-ready, complete. Inception triggers Chat's validation directive in the session brief. Exploring through spec-ready are normal session flow — phase is context on the brief but doesn't alter Chat's behavior. Complete is terminal and the idea leaves the landing page. CC manages phase display; the developer decides when to advance."
- NEW DECISION: "Idea advanced to spec-ready phase. All in-scope OPENs resolved, Decision coverage is comprehensive across session packaging, chain model, skill architecture, pacing, landing page, session cards, ingestion flow, idea lifecycle, and brief generation."
- NEW DECISION: "Spec is broken into 5 logical units executed as sequential sessions: (1) session.json schema & package format, (2) session lifecycle & idea phase model, (3) skill updates (cc-link-output, cc-summation-link, cc-odrc-framework, cc-session-structure), (4) landing page & session card UX, (5) ingestion pipeline. Each spec session produces the spec document plus a Decision validation checkpoint that maps covered Decisions to their spec implementation and flags gaps or conflicts."

## Session Notes

### What Was Accomplished
This session performed a spec-readiness assessment for the Session Tab idea. All 13 open OPENs were systematically cross-referenced against the existing Decision body. Five had already been resolved by prior Decisions but never formally closed. Three were resolved through new Decisions in this session. Two were reclassified as processor concerns (out of scope). Two remain parked for future work (idea management and evolution history). One was resolved by the new idea phase field Decision.

The idea was advanced to spec-ready. A 5-unit spec plan was defined with a sequencing strategy (schema first, then lifecycle, then skills, then UX, then ingestion) and a validation checkpoint methodology where each spec maps its Decisions and flags concerns.

### Key Design Principles Established
- The chain model is a pitstop framework, not a mandatory structure — the gas tank analogy drives the design
- Scope discipline matters — processor concerns were explicitly carved out rather than trying to resolve everything in one idea
- Spec decomposition into logical units with validation checkpoints catches drift between units early
- Phase field serves two audiences: CC uses full granularity for display, Chat only cares about the inception boundary

### Session Status
- Concepts: 11 OPENs resolved, 6 DECISIONs (new), 0 RULEs, 0 CONSTRAINTs
- Phase: spec-ready
- Next session: Begin spec Unit 1 — session.json schema & package format. This is the foundational contract all other units build against.
